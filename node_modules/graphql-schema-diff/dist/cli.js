#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const meow_1 = __importDefault(require("meow"));
const chalk_1 = __importDefault(require("chalk"));
const html_1 = require("./html");
const diff_1 = require("./diff");
const cli = (0, meow_1.default)(`
  Usage
    $ graphql-schema-diff <leftSchemaLocation> <rightSchemaLocation>

  Options
    --fail-on-dangerous-changes  Exit with error on dangerous changes
    --fail-on-breaking-changes \t Exit with error on breaking changes
    --fail-on-all-changes \t Exit with error on all changes
    --use-colors \t\t Use colors for diff terminal output
    --create-html-output \t Creates an HTML file containing the diff
    --html-output-directory \t Directory where the HTML file should be stored (Default: './schemaDiff')
    --header, -H \t\t Header to send to all remote schema sources
    --left-schema-header \t Header to send to left remote schema source
    --right-schema-header \t Header to send to right remote schema source
    --sort-schema, -s \t\t Sort schemas prior to diffing

  Examples
    $ graphql-schema-diff https://example.com/graphql schema.graphql
    $ graphql-schema-diff https://example.com/graphql schema.graphql -H 'Authorization: Bearer 123'
`, {
    flags: {
        failOnDangerousChanges: {
            type: "boolean",
        },
        failOnBreakingChanges: {
            type: "boolean",
        },
        failOnAllChanges: {
            type: "boolean",
        },
        useColors: {
            type: "boolean",
        },
        createHtmlOutput: {
            type: "boolean",
        },
        htmlOutputDirectory: {
            type: "string",
            default: "schemaDiff",
        },
        header: {
            type: "string",
            alias: "H",
        },
        leftSchemaHeader: {
            type: "string",
        },
        rightSchemaHeader: {
            type: "string",
        },
        sortSchema: {
            type: "boolean",
            alias: "s",
        },
        help: {
            alias: "h",
        },
        version: {
            alias: "v",
        },
    },
});
function parseHeaders(headerInput) {
    let headers;
    const parseHeader = (header) => header.split(":").map((val) => val.trim());
    if (!headerInput)
        return;
    if (Array.isArray(headerInput)) {
        headers = headerInput.map(parseHeader);
    }
    else {
        headers = [parseHeader(headerInput)];
    }
    return headers.reduce((result, [key, value]) => ({
        ...result,
        ...(key && value && { [key]: value }),
    }), {});
}
const [leftSchemaLocation, rightSchemaLocation] = cli.input;
const { header, leftSchemaHeader, rightSchemaHeader, } = cli.flags;
if (!leftSchemaLocation || !rightSchemaLocation) {
    console.error(chalk_1.default.red("ERROR: Schema locations missing!\n\n"), chalk_1.default.gray("Usage\n" +
        "  $ graphql-schema-diff <leftSchemaLocation> <rightSchemaLocation>"));
    process.exit(1);
}
(0, diff_1.getDiff)(leftSchemaLocation, rightSchemaLocation, {
    headers: parseHeaders(header),
    leftSchema: {
        headers: parseHeaders(leftSchemaHeader),
    },
    rightSchema: {
        headers: parseHeaders(rightSchemaHeader),
    },
    sortSchema: cli.flags.sortSchema,
})
    .then(async (result) => {
    if (result === undefined) {
        console.warn(chalk_1.default.green("✔ No changes"));
        return;
    }
    const hasBreakingChanges = result.breakingChanges.length !== 0;
    const hasDangerousChanges = result.dangerousChanges.length !== 0;
    if (cli.flags.useColors) {
        console.log(result.diff);
    }
    else {
        console.log(result.diffNoColor);
    }
    if (hasDangerousChanges) {
        console.warn(chalk_1.default.yellow.bold.underline("Dangerous changes"));
        for (const change of result.dangerousChanges) {
            console.warn(chalk_1.default.yellow("  ⚠ " + change.description));
        }
    }
    if (hasDangerousChanges && hasBreakingChanges) {
        console.warn(); // Add additional line break
    }
    if (hasBreakingChanges) {
        console.warn(chalk_1.default.red.bold.underline("BREAKING CHANGES"));
        for (const change of result.breakingChanges) {
            console.warn(chalk_1.default.red("  ✖ " + change.description));
        }
    }
    if (cli.flags.createHtmlOutput) {
        await (0, html_1.createHtmlOutput)(result.diffNoColor, {
            outputDirectory: cli.flags.htmlOutputDirectory,
        });
    }
    if ((hasDangerousChanges && cli.flags.failOnDangerousChanges) ||
        (hasBreakingChanges && cli.flags.failOnBreakingChanges) ||
        cli.flags.failOnAllChanges) {
        process.exit(1);
        return;
    }
})
    .catch((err) => {
    console.error(chalk_1.default.red(`\nERROR: ${err.message}`));
    process.exit(1);
});
